# 并查集

## 引言

并查集是一种用于管理元素所属集合的数据结构，实现为一个森林，其中每棵树表示一个集合，树中的节点表示对应集合中的元素。

顾名思义，并查集支持两种操作，且每次操作时间复杂度 $\Theta(\alpha(n))$ 。（可理解为是一个很小的常数）

- 合并（Union）：合并两个元素所属集合（合并对应的树）

- 查询（Find）：查询某个元素所属集合（查询对应的树的根节点），这可以用于判断两个元素是否属于同一集合

  （所以经常被用来维护连通性，如 $kruskal$ 算法）

并查集在经过修改后可以支持单个元素的删除、移动；使用动态开点线段树还可以实现可持久化并查集。

## 代码模板（理解记忆）

### 初始化

初始时我们维护一个数组 $f[n]$ ，每个元素都位于一个单独的集合，表示为一棵只有根节点的树。方便起见，我们将根节点的父亲设为自己。

```c++
void init()
{
    for(int i=1;i<=n;i++)  //n个点
		f[i]=i;
}
```



### 查询

我们想要 $find$ 某个节点的根节点，只需要沿着树向上移动，直至找到根节点即可。

在这里我们可以采取路径压缩优化以加快查询速度。

![img](C:\Users\Fengmi123\Pictures\Camera Roll\disjoint-set-compress.svg)

```C++
int find(int x)    //路径压缩
{
	if(f[x]==x)               //如果我爸爸是我自己
		return x;             //返回自己
	return f[x]=find(f[x]);   //否则继续找爸爸的爸爸
}
```



### 合并

要合并两棵树，我们只需要将一棵树的根节点连到另一棵树的根节点。

![img](C:\Users\Fengmi123\Pictures\Camera Roll\disjoint-set-merge.svg)

```c++
void union(int x,int y)
{
    int fx=find(x),fy=find(y);  //先找祖宗
    if(fx!=fy)					//如果俩祖宗不一样
    	f[fx]=fy;				//就让祖宗杂交到一起
}
```



### 启发式合并

合并时，选择哪棵树的根节点作为新树的根节点会影响未来操作的复杂度。我们可以将节点较少或深度较小的树连到另一棵，以免发生退化，更加优化时间复杂度，常见于可持久化并查集和线段树分治中。

```c++
void union(int x,int y)
{
    int fx=find(x),fy=find(y);  
    if(fx==fy)				
    	return;
    if(size[x]<size[y])
        swap(x,y);
    f[fy]=fx;           //小连大，fx成为fy的祖宗
    size[x]+=size[y];   //维护size数组记录不同根节点的子树大小
}
```



### 删除

对于删除操作，在完美的并查集中（所有节点都直接连接在根节点上）理论上只要把要删除的节点的上级重新指向自己就可以了。但是实际情况中，我们的并查集形成的树的形态都是不可预估形态的，如果直接将一个节点指向自己可能会将他的“下级”和他一块删除，这就和我们的想法违背了。所以在一个需要删除的并查集中初始化时就要处理一下：

- 首先每个节点不再指向自己而是另一个比不会出现的节点，类似于将每个节点放到一个盒子中
- 这样，删除时只需要把这个节点从当前盒子拿出来，放到另一个盒子中
- 由于节点之间都是通过盒子来确定关系的，所以盒子中元素是否存在并不影响节点之间的关系

```C++
//提前开好两倍空间
void init()
{
    for(int i=1;i<=n;i++)     //每个元素i的父节点是盒子节点n+i
        f[i]=n+i;		 //此时普通节点为1~n,盒子节点为n+1~2*n,合并时通过盒子节点合并
    for(int i=n+1;i<=2*n;i++)   //盒子节点指向自己就像一般的并查集一样
        f[i]=i;
}
void delete(int x)
{
    int fx=find(x);
    //size[x]--;      //维护子树大小
    f[n+x]=x;
    f[x]=x;
}
```



### 移动

使用 $find$ 函数分别找到 $x$ 和 $y$ 的根节点，分别存储在 $fx$ 和 $fy$ 中，如果 $x$ 和 $y$ 已经在同一个集合中（即 $fx == fy$），函数直接返回，因为不需要移动。

* 更新父节点：

将 $x$ 的父节点直接设置为 $fy$，这样 $x$ 现在属于 $y$ 的集合。这是移动操作的核心，直接修改父节点可以快速改变元素的集合归属。

* 更新集合大小：

从 $x$ 原来的集合的大小中减去 $1$，因为 $x$ 被移出了这个集合。向 $y$ 的集合的大小中加上 $1$ ，因为 $x$ 被加入到了这个集合。

```c++
void move(int x,int y)    //将x移入y
{
    int fx=find(x),fy=find(y);
    if (fx==fy) 
        return;  // 如果x和y已经在同一个集合中，则无需移动
    f[x]=fy;  // 将x的父节点直接设置为y的根节点
    //--size[fx];  // 从x原来的集合中减去1
    //++size[fy];  // 将x加入到y的集合中
}
```



#### 此处给出一些经典并查集操作练习题

参考难度：${\color{limegreen}{【普及/提高-】}}$

[P1197 星球大战](https://www.luogu.com.cn/problem/P1197)

[P2024 食物链](https://www.luogu.com.cn/problem/P2024)

[P1196 银河英雄传说](https://www.luogu.com.cn/problem/P1196)

[P1525 关押罪犯](https://www.luogu.com.cn/problem/P1525)

[P1892 团伙](https://www.luogu.com.cn/problem/P1892)

## 并查集的应用

### 1st

最基础的应用——利用并查集的传递性与连通性

在并查集合并的时候记录「并查集生成树」，也就是说如果第 $i$ 次操作 $a_i$ 和 $b_i$ 分属于两个不同子树，那么把 $(a_i,b_i) $这条边纳入生成树中。若边权是 $i$，询问 $u$ 到 $v$ 路径上边权的最大值，时间复杂度$ \Theta(n\log n)$。

另外一个方法是维护 $Kruskal$ 重构树，其本质与并查集生成树是相同的。复杂度亦相同。

### 2nd

#### 带权并查集

在对并查集进行路径压缩和合并操作时，这些权值具有一定属性，即可将他们与父节点的关系，变化为与所在树的根结点关系。

也就是说，权值代表着**当前节点与父节点的某种关系（即使路径压缩了也是这样）**，通过两者关系，也可以将同一棵树下两个节点的关系表示出来。

由于合并时一起传递了权值，思想类似于前缀和，常见时间复杂度 $\Theta(n\alpha(n))$ 。

```c++
int find(int x)
{
    if(f[x]==x)      
		return x;
	else
	{
		f[x]=find(f[x]);
		value[x]+=value[f[x]];  //更新权值
	}
	return f[x];
}
```

```c++
void union(int x,iny y)
{
    int fx=find(x),fy=find(y);  
    if(fx!=fy)
    {
        f[fx]=fy;
        value[fx] = -value[x] + value[y] + s;  //显然x到py两条路径的权值之和应该相同，即可推出该式
    }
}
```

![noi](C:\Users\Fengmi123\Pictures\Camera Roll\372e16896717bb2e74463f5ed5a17241.jpeg)

### 3rd

#### 种类并查集

并查集可以很方便地维护联通关系，但对于想要表达**对立关系**的情况来说，正常的并查集就很难满足我们的需求。

考虑开 $k$ 倍的并查集，利用在不同种类的并查集中合并的意义来维护**对立关系**

```C++
/*
	** 每次union都要进行n次 **
*/
void friends(int x,int y)   //在同类并查集间建边
{
	for(int i=0;i<k;i++)	// if(find(x)==find(y) -> friend  // if(find(x)==find(i*y) -> conflict
    {
        union(x+i*n,y+i*n);
    }
}

void conflict(int x,int y)	//在不同类并查集间建边
{
    for(int i=0;i<k;i++)
    {
        for(int j=0;j<k;j++)
        {
            if(i==j)
                continue;
            union(x+i*n,y+j*n);
        }
    }
}
```
